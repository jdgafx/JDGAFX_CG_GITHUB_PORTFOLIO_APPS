import '@xyflow/react/dist/style.css'
import { useState, useCallback, useRef, useEffect } from 'react'
import {
  ReactFlow,
  Background,
  Controls,
  useNodesState,
  useEdgesState,
  type NodeTypes,
  type Node,
  type Edge,
} from '@xyflow/react'
import { Bot, ChevronRight, Square, Download, FileText } from 'lucide-react'
import { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx'
import { saveAs } from 'file-saver'
import { jsPDF } from 'jspdf'
import { AgentNode } from './components/AgentNode'
import { startResearch } from './lib/api'
import type { AgentRole, AgentState, StreamEvent } from './types'

const nodeTypes: NodeTypes = { agent: AgentNode as unknown as NodeTypes[string] }

const AGENT_ORDER: AgentRole[] = ['researcher', 'analyst', 'critic', 'synthesizer']

const AGENT_LABELS: Record<AgentRole, string> = {
  researcher: 'Research Findings',
  analyst: 'Analysis',
  critic: 'Critical Review',
  synthesizer: 'Final Synthesis',
}

const AGENT_ACTIVITY: Record<AgentRole, { working: string; complete: string; idle: string }> = {
  researcher: {
    working: 'Gathering data, statistics, and key findings from multiple sources...',
    complete: 'Research complete — findings ready for analysis.',
    idle: 'Standing by to research your topic.',
  },
  analyst: {
    working: 'Analyzing research findings — identifying patterns, correlations, and insights...',
    complete: 'Analysis complete — structured insights ready for review.',
    idle: 'Waiting for research data to analyze.',
  },
  critic: {
    working: 'Reviewing analysis for gaps, biases, and missing perspectives...',
    complete: 'Critical review complete — feedback incorporated.',
    idle: 'Waiting for analysis to review.',
  },
  synthesizer: {
    working: 'Combining all findings into a polished, comprehensive final report...',
    complete: 'Synthesis complete — final report ready to download.',
    idle: 'Waiting for all agents to finish before synthesizing.',
  },
}

const DEFAULT_AGENTS: Record<AgentRole, AgentState> = {
  researcher: { id: 'researcher', name: 'Research Agent', description: 'Gathers data & findings', status: 'idle', output: '', tokens: 0 },
  analyst: { id: 'analyst', name: 'Analyst Agent', description: 'Identifies patterns', status: 'idle', output: '', tokens: 0 },
  critic: { id: 'critic', name: 'Critic Agent', description: 'Reviews for gaps', status: 'idle', output: '', tokens: 0 },
  synthesizer: { id: 'synthesizer', name: 'Synthesizer Agent', description: 'Produces final report', status: 'idle', output: '', tokens: 0 },
}

function buildNodes(agents: Record<AgentRole, AgentState>): Node[] {
  return AGENT_ORDER.map((role, i) => ({
    id: role,
    type: 'agent',
    position: { x: 30, y: i * 175 + 20 },
    data: agents[role] as unknown as Record<string, unknown>,
  }))
}

const STATIC_EDGES: Edge[] = AGENT_ORDER.slice(0, -1).map((role, i) => ({
  id: `e-${role}`,
  source: role,
  target: AGENT_ORDER[i + 1] as string,
  animated: false,
}))

function formatTime(s: number): string {
  return `${Math.floor(s / 60)}:${String(s % 60).padStart(2, '0')}`
}

async function generateDocx(query: string, agents: Record<AgentRole, AgentState>): Promise<void> {
  const children: Paragraph[] = [
    new Paragraph({
      children: [new TextRun({ text: `Research Report: ${query}`, bold: true, size: 48 })],
      spacing: { after: 200 },
    }),
    new Paragraph({
      children: [new TextRun({ text: 'Generated by AgentFlow Multi-Agent AI Pipeline', italics: true, size: 20, color: '888888' })],
      spacing: { after: 600 },
    }),
  ]
  for (const role of AGENT_ORDER) {
    const output = agents[role].output || 'No output generated.'
    children.push(
      new Paragraph({
        text: AGENT_LABELS[role],
        heading: HeadingLevel.HEADING_1,
        spacing: { before: 400, after: 200 },
      }),
    )
    const paras = output.split(/\n\n+/).filter(p => p.trim())
    for (const para of paras) {
      children.push(
        new Paragraph({
          children: [new TextRun({ text: para.trim(), size: 22 })],
          spacing: { after: 160 },
        }),
      )
    }
  }
  const doc = new Document({ sections: [{ children }] })
  const blob = await Packer.toBlob(doc)
  const slug = query.slice(0, 40).replace(/[^a-z0-9]/gi, '-').toLowerCase()
  saveAs(blob, `research-report-${slug}.docx`)
}

function generatePdf(query: string, agents: Record<AgentRole, AgentState>): void {
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' })
  const pageW = pdf.internal.pageSize.getWidth()
  const pageH = pdf.internal.pageSize.getHeight()
  const margin = 20
  const maxW = pageW - margin * 2
  let y = margin

  function addLine(text: string, size: number, bold: boolean, r: number, g: number, b: number): void {
    pdf.setFontSize(size)
    pdf.setFont('helvetica', bold ? 'bold' : 'normal')
    pdf.setTextColor(r, g, b)
    const lines = pdf.splitTextToSize(text, maxW) as string[]
    for (const line of lines) {
      if (y + size * 0.5 > pageH - margin) {
        pdf.addPage()
        y = margin
      }
      pdf.text(line, margin, y)
      y += size * 0.45
    }
  }

  addLine('Research Report', 22, true, 0, 180, 220)
  y += 2
  addLine(query, 15, false, 30, 40, 60)
  y += 3
  addLine('Generated by AgentFlow Multi-Agent AI Pipeline', 9, false, 120, 130, 150)
  y += 8
  pdf.setDrawColor(0, 180, 220)
  pdf.setLineWidth(0.5)
  pdf.line(margin, y, pageW - margin, y)
  y += 8

  for (const role of AGENT_ORDER) {
    const output = agents[role].output || 'No output generated.'
    const clean = output.replace(/#{1,6}\s*/g, '').replace(/\*\*/g, '').replace(/\*/g, '').replace(/`/g, '')
    addLine(AGENT_LABELS[role], 13, true, 0, 140, 180)
    y += 2
    addLine(clean, 10, false, 30, 40, 60)
    y += 5
    if (y < pageH - margin - 10) {
      pdf.setDrawColor(200, 210, 220)
      pdf.setLineWidth(0.2)
      pdf.line(margin, y, pageW - margin, y)
      y += 6
    }
  }

  const slug = query.slice(0, 40).replace(/[^a-z0-9]/gi, '-').toLowerCase()
  pdf.save(`research-report-${slug}.pdf`)
}

export default function App() {
  const [agents, setAgents] = useState<Record<AgentRole, AgentState>>(DEFAULT_AGENTS)
  const [query, setQuery] = useState('')
  const [isRunning, setIsRunning] = useState(false)
  const [isPipelineComplete, setIsPipelineComplete] = useState(false)
  const [activeTab, setActiveTab] = useState<AgentRole>('researcher')
  const [elapsed, setElapsed] = useState(0)
  const [totalTokens, setTotalTokens] = useState(0)

  const abortRef = useRef<AbortController | null>(null)
  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null)

  const [nodes, setNodes, onNodesChange] = useNodesState(buildNodes(DEFAULT_AGENTS))
  const [edges, setEdges, onEdgesChange] = useEdgesState(STATIC_EDGES)

  const syncNodes = useCallback(
    (next: Record<AgentRole, AgentState>) => setNodes(buildNodes(next)),
    [setNodes],
  )

  const handleEvent = useCallback(
    (event: StreamEvent) => {
      if (event.type === 'agent_start') {
        setActiveTab(event.agent)
        setAgents(prev => {
          const next = { ...prev, [event.agent]: { ...prev[event.agent], status: 'working' as const, startTime: Date.now() } }
          syncNodes(next)
          return next
        })
        setEdges(prev => prev.map(e => ({ ...e, animated: e.source === event.agent || e.target === event.agent })))
      } else if (event.type === 'agent_chunk') {
        setAgents(prev => {
          const next = { ...prev, [event.agent]: { ...prev[event.agent], output: prev[event.agent].output + (event.content ?? '') } }
          syncNodes(next)
          return next
        })
      } else if (event.type === 'agent_complete') {
        const tokens = event.tokens ?? 0
        setAgents(prev => {
          const next = { ...prev, [event.agent]: { ...prev[event.agent], status: 'complete' as const, tokens, endTime: Date.now() } }
          syncNodes(next)
          return next
        })
        setTotalTokens(prev => prev + tokens)
        setEdges(prev => prev.map(e => ({ ...e, animated: false })))
      } else if (event.type === 'agent_error') {
        setAgents(prev => {
          const next = { ...prev, [event.agent]: { ...prev[event.agent], status: 'error' as const } }
          syncNodes(next)
          return next
        })
      } else if (event.type === 'session_complete') {
        setIsPipelineComplete(true)
        setActiveTab('synthesizer')
      }
    },
    [syncNodes, setEdges, setIsPipelineComplete],
  )

  const handleStart = useCallback(async () => {
    if (!query.trim() || isRunning) return

    const fresh = { ...DEFAULT_AGENTS }
    setAgents(fresh)
    syncNodes(fresh)
    setEdges(STATIC_EDGES)
    setTotalTokens(0)
    setElapsed(0)
    setIsRunning(true)
    setIsPipelineComplete(false)
    setActiveTab('researcher')

    const start = Date.now()
    timerRef.current = setInterval(() => setElapsed(Math.floor((Date.now() - start) / 1000)), 250)

    const ctrl = new AbortController()
    abortRef.current = ctrl

    try {
      await startResearch(query, handleEvent, ctrl.signal)
    } catch (err) {
      if ((err as Error).name !== 'AbortError') console.error(err)
    } finally {
      setIsRunning(false)
      if (timerRef.current) clearInterval(timerRef.current)
      setEdges(prev => prev.map(e => ({ ...e, animated: false })))
    }
  }, [query, isRunning, handleEvent, syncNodes, setEdges])

  const handleStop = useCallback(() => abortRef.current?.abort(), [])

  const handleDownloadDocx = useCallback(() => {
    generateDocx(query, agents).catch(console.error)
  }, [query, agents])

  const handleDownloadPdf = useCallback(() => {
    generatePdf(query, agents)
  }, [query, agents])

  useEffect(
    () => () => {
      abortRef.current?.abort()
      if (timerRef.current) clearInterval(timerRef.current)
    },
    [],
  )

  const activeAgent = agents[activeTab]
  const isActiveWorking = activeAgent.status === 'working' || activeAgent.status === 'thinking'

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100dvh', background: '#0a0e1a' }}>
      <header
        style={{
          padding: '10px 24px 10px',
          borderBottom: '1px solid rgba(255,255,255,0.08)',
          background: '#111827',
          flexShrink: 0,
        }}
      >
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
            <div style={{ padding: 7, borderRadius: 10, background: 'rgba(0,212,255,0.12)', color: '#00d4ff', display: 'flex' }}>
              <Bot size={20} />
            </div>
            <span style={{ fontSize: 17, fontWeight: 700, color: '#f1f5f9', letterSpacing: -0.3 }}>AgentFlow</span>
          </div>
          <div style={{ display: 'flex', alignItems: 'center', gap: 20, fontSize: 13, color: '#94a3b8' }}>
            {isRunning && (
              <span style={{ color: '#00d4ff', fontFamily: 'monospace', fontWeight: 600 }}>
                {formatTime(elapsed)}
              </span>
            )}
            {isPipelineComplete && (
              <span style={{ color: '#00ff88', fontSize: 12, fontWeight: 600 }}>✓ Research Complete</span>
            )}
            {totalTokens > 0 && <span>{totalTokens.toLocaleString()} tokens</span>}
          </div>
        </div>
        <p style={{ margin: '7px 0 0 0', fontSize: 11.5, color: '#64748b', lineHeight: 1.55, maxWidth: 860 }}>
          Multi-Agent AI Research Pipeline — Enter any research topic and watch 4 specialized AI agents collaborate in sequence: a Researcher gathers findings, an Analyst identifies patterns, a Critic reviews for gaps, and a Synthesizer produces a polished final report. Download the complete report as PDF or Word document when finished.
        </p>
      </header>

      <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
        <div style={{ flex: 1, position: 'relative' }}>
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            nodeTypes={nodeTypes}
            fitView
            fitViewOptions={{ padding: 0.3 }}
            proOptions={{ hideAttribution: true }}
          >
            <Background color="rgba(255,255,255,0.025)" gap={28} size={1} />
            <Controls showInteractive={false} />
          </ReactFlow>

          {(isRunning || isPipelineComplete) && (
            <div
              style={{
                position: 'absolute',
                right: 16,
                top: '50%',
                transform: 'translateY(-50%)',
                width: 260,
                padding: '16px 18px',
                borderRadius: 16,
                background: 'rgba(17,24,39,0.92)',
                backdropFilter: 'blur(20px)',
                border: `1px solid ${isRunning ? 'rgba(0,212,255,0.2)' : 'rgba(0,255,136,0.2)'}`,
                boxShadow: isRunning
                  ? '0 0 30px rgba(0,212,255,0.08)'
                  : '0 0 30px rgba(0,255,136,0.08)',
                zIndex: 10,
              }}
            >
              <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginBottom: 10 }}>
                <div
                  className={isRunning ? 'agent-active' : ''}
                  style={{
                    width: 10,
                    height: 10,
                    borderRadius: '50%',
                    background: isRunning ? '#00d4ff' : '#00ff88',
                    boxShadow: isRunning ? '0 0 8px #00d4ff' : '0 0 8px #00ff88',
                  }}
                />
                <span style={{ fontSize: 13, fontWeight: 700, color: isRunning ? '#00d4ff' : '#00ff88' }}>
                  {isPipelineComplete ? 'Pipeline Complete' : agents[activeTab].name}
                </span>
              </div>
              <p style={{ margin: 0, fontSize: 11.5, color: '#94a3b8', lineHeight: 1.55 }}>
                {isPipelineComplete
                  ? AGENT_ACTIVITY.synthesizer.complete
                  : AGENT_ACTIVITY[activeTab][agents[activeTab].status === 'complete' ? 'complete' : agents[activeTab].status === 'idle' ? 'idle' : 'working']}
              </p>

              {isRunning && (
                <div style={{ marginTop: 12, display: 'flex', gap: 6 }}>
                  {AGENT_ORDER.map(role => (
                    <div
                      key={role}
                      style={{
                        flex: 1,
                        height: 3,
                        borderRadius: 2,
                        background:
                          agents[role].status === 'complete'
                            ? '#00ff88'
                            : agents[role].status === 'working'
                              ? '#00d4ff'
                              : 'rgba(255,255,255,0.08)',
                        transition: 'background 0.3s',
                      }}
                    />
                  ))}
                </div>
              )}
            </div>
          )}
        </div>

        <div
          style={{
            width: 400,
            display: 'flex',
            flexDirection: 'column',
            borderLeft: '1px solid rgba(255,255,255,0.08)',
          }}
        >
          <div
            style={{
              display: 'flex',
              borderBottom: '1px solid rgba(255,255,255,0.08)',
              background: '#111827',
              flexShrink: 0,
            }}
          >
            {AGENT_ORDER.map(role => (
              <button
                key={role}
                onClick={() => setActiveTab(role)}
                style={{
                  flex: 1,
                  padding: '10px 4px',
                  fontSize: 11,
                  fontWeight: 500,
                  textTransform: 'capitalize',
                  background: 'transparent',
                  border: 'none',
                  borderBottom: activeTab === role ? '2px solid #00d4ff' : '2px solid transparent',
                  color: activeTab === role ? '#00d4ff' : '#64748b',
                  cursor: 'pointer',
                  transition: 'color 0.15s',
                }}
              >
                {role}
                {agents[role].status === 'complete' && (
                  <span style={{ color: '#00ff88', marginLeft: 3 }}>✓</span>
                )}
                {(agents[role].status === 'working' || agents[role].status === 'thinking') && (
                  <span style={{ color: '#00d4ff', marginLeft: 3 }}>●</span>
                )}
              </button>
            ))}
          </div>

          <div
            style={{
              flex: 1,
              overflowY: 'auto',
              padding: '16px',
              fontFamily: "'JetBrains Mono', monospace",
              fontSize: 12,
              lineHeight: 1.65,
              color: '#94a3b8',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-word',
            }}
          >
            {activeAgent.output ? (
              <span className={isActiveWorking ? 'typing-cursor' : ''}>{activeAgent.output}</span>
            ) : (
              <span style={{ color: '#475569', fontStyle: 'italic' }}>
                {activeAgent.status === 'idle' ? 'Waiting for task...' : 'Processing...'}
              </span>
            )}
          </div>
        </div>
      </div>

      {isPipelineComplete && (
        <div
          style={{
            padding: '10px 20px',
            borderTop: '1px solid rgba(0,212,255,0.2)',
            background: 'rgba(0,212,255,0.04)',
            display: 'flex',
            alignItems: 'center',
            gap: 12,
            flexShrink: 0,
          }}
        >
          <span style={{ fontSize: 12, color: '#64748b', flex: 1 }}>
            Pipeline complete — download your full research report:
          </span>
          <button
            onClick={handleDownloadPdf}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: 6,
              padding: '7px 14px',
              borderRadius: 10,
              fontSize: 12,
              fontWeight: 600,
              cursor: 'pointer',
              background: 'rgba(255,51,102,0.1)',
              color: '#ff3366',
              border: '1px solid rgba(255,51,102,0.3)',
              fontFamily: 'inherit',
            }}
          >
            <Download size={13} />
            Download PDF
          </button>
          <button
            onClick={handleDownloadDocx}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: 6,
              padding: '7px 14px',
              borderRadius: 10,
              fontSize: 12,
              fontWeight: 600,
              cursor: 'pointer',
              background: 'rgba(68,136,255,0.1)',
              color: '#4488ff',
              border: '1px solid rgba(68,136,255,0.3)',
              fontFamily: 'inherit',
            }}
          >
            <FileText size={13} />
            Download DOCX
          </button>
        </div>
      )}

      <div
        style={{
          padding: '12px 20px',
          borderTop: '1px solid rgba(255,255,255,0.08)',
          background: '#111827',
          flexShrink: 0,
        }}
      >
        <div style={{ display: 'flex', gap: 10 }}>
          <input
            type="text"
            value={query}
            onChange={e => setQuery(e.target.value)}
            onKeyDown={e => e.key === 'Enter' && !e.shiftKey && handleStart()}
            placeholder="Enter research query..."
            disabled={isRunning}
            style={{
              flex: 1,
              padding: '10px 16px',
              borderRadius: 12,
              background: 'rgba(17,24,39,0.7)',
              border: '1px solid rgba(255,255,255,0.08)',
              color: '#f1f5f9',
              fontSize: 14,
              outline: 'none',
              fontFamily: 'inherit',
            }}
          />
          <button
            onClick={isRunning ? handleStop : handleStart}
            disabled={!isRunning && !query.trim()}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: 6,
              padding: '10px 20px',
              borderRadius: 12,
              fontSize: 13,
              fontWeight: 600,
              cursor: !isRunning && !query.trim() ? 'not-allowed' : 'pointer',
              background: isRunning ? 'rgba(255,51,102,0.12)' : 'rgba(0,212,255,0.1)',
              color: isRunning ? '#ff3366' : '#00d4ff',
              border: isRunning ? '1px solid rgba(255,51,102,0.3)' : '1px solid rgba(0,212,255,0.3)',
              transition: 'all 0.15s',
              opacity: !isRunning && !query.trim() ? 0.5 : 1,
              fontFamily: 'inherit',
            }}
          >
            {isRunning ? (
              <><Square size={13} /> Stop</>
            ) : (
              <><ChevronRight size={13} /> Start Research</>
            )}
          </button>
        </div>
      </div>
      <footer style={{ textAlign: 'center', padding: '12px 0', fontSize: 11, color: '#475569', borderTop: '1px solid rgba(255,255,255,0.05)' }}>
        Authored by Christopher Gentile / CGDarkstardev1 / NewDawn AI
      </footer>
    </div>
  )
}
